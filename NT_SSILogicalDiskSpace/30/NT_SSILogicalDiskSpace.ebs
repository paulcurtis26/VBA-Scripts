'### This is an .ebs file generated by KSCheckout.
'### It can be checked in to the repository by invoking kscheckin.
'###
'### NT_SSILogicalDiskSpace

'$Revision: 14 $

'### Begin KP-Version Section
Const AppManID = "3.0.361.8.14"
Const KSVerID = "3.0"
'Comment=  Changed to Command Post 3.0 Syntax
'### End KP-Version Section


'### Begin KP-Status Section
'NeedKPW = 0
'AdminOnly = 0
'DisplayToolBar = 1
'IAmDiscovery = 0
'IAmAction = 0
'Description = Monitor if the Logical Disk(s) is getting full

'### End KP-Status Section

'### Begin KPC Section
'Parameters = 0 128 0 8 24 0 0 2147483647 0 99991231 0 235959

'### End KPC Section

'### Begin Type Section
Const NT_LogicalDiskObj = ""

'### End Type Section

'### Begin KPP Section

'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 31/3/99
'### Revision       : 1.9
'### Enhancements 	: -Added more debug information

'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 8/4/99
'### Revision       : 2.0
'### Enhancements 	: -Fixed issue with Overflow for below threshold counter for disk structure

'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 16/6/99
'### Revision       : 2.1
'### Enhancements 	: -Added Code to alway send auto clear if Action is Command Post

'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 20/7/99
'### Revision       : 2.2
'### Enhancements 	: -Changed to Command Post 3.0 Syntax
'### 			 	: -Changed to Err.Raise statements to MCAbort 

'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 20/7/99
'### Revision       : 3.0
'### Enhancements 	: -Using GetDiskFreeSpaceEx API (from NetIQ Script)
'### 			 	

'[V<CPReady3. Disk Util monitors the disk space usage (in %). Free Space indicates the space free (in MB). Event is raised if ANY disk's usage is over Max Disk Utilization (%) OR the free space is below Min Free Space (MB). (Version 3.0)>V]
'[A<When the disk space is getting full, the selected action is taken.>A]
Const DO_EVENT = "y"			'[M<Event? (y/n)>M] [T<String,1,,"yn">T]
Const DO_DATA = "n"				'[M<Collect Data? (y/n)>M] [T<String,100,,"yn">T]
Const DO_NUMBERS = "y" '[M<Show numbers? (y/n)>M][T<string,1,' ',yn">T]
Const DISKS = "C,D,E,F"			'[M<List Disks to Monitor separated by "," w/ no space.>M] [T<String,1000,',',>T]
Const TH_UTIL = "95,95,95,95"	'[M<Max Disk Utilization (%) limit for above disks separated by "," w/ no space.>M] [T<String,1000,',',>T]
Const TH_FREE = "10,10,10,10"	'[M<Min Free Space (MB) for above disks separated by "," w/ no space.>M] [T<String,1000,',',>T]
Const CONSEC_TIME_ABOVE = 3		'[M<Consecutive times above>M] [T<long,,,1, 999999, #>T]
Const CONSEC_TIME_BELOW = 3		'[M<Consecutive times below>M] [T<long,,,1, 999999, #>T]
Const DEF_UTIL = 95				'[M<Other Disk Util > >M] [T<Integer,,, 0, 100, %>T]
Const DEF_FREE = 10				'[M<Other Disk Free Space < >M] [T<Integer,,, 0, 9999, MB>T]
Const Severity = 8				'[M<Event Severity>M] [T<Integer,,,1, 40, SevLevel>T]
Const Debug = "n"			'[M< Write Debug Information to File ? (y/n)>M] [T<String,1,,"yn">T]
Const SEND_NORMAL = "y"			'[M<Send Mesage When Disk Space is Normal (AutoClear Message) ? (y/n)>M] [T<String,1,,"yn">T]
Const AKPID = "AKP_NULL"	' [M<Action Taken>M]

'### End KPP Section

'### Begin KPS Section
Type ULARGE_INTEGER
	LowPart As Long
	HighPart As Long
End Type

Declare Function GetDiskFreeSpaceEx Lib "kernel32.dll" Alias "GetDiskFreeSpaceExA" _
	(ByVal lpRootPathName As String, ByRef lpFreeBytesAvailableToCaller As ULARGE_INTEGER, _
	ByRef lpTotalNumberOfBytes As ULARGE_INTEGER, ByRef lpTotalNumberOfFreeBytes As ULARGE_INTEGER) As Long
Declare Function RegCloseKey Lib "advapi32.dll" _ 
		(ByVal hKey As Long) As Long 
Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias _ 
		"RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, _ 
		ByVal ulOptions As Long, ByVal samDesired As Long, ByRef phkResult As Long) As Long 
Declare Function RegQueryValueExString Lib "advapi32.dll" Alias _ 
		"RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _ 
		String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
		As String, lpcbData As Long) As Long 

Global Const REG_SZ As Long      = 1
Global Const HKEY_LOCAL_MACHINE  = &H80000002 
Global Const KEY_READ            = &H19
Global Const Error_None          = 0
Global Const NT_MajorVersion_351 = "3.51"
Global Const NT_MajorVersion_40  = "4.0"
Declare Function GetComputerName Lib "kernel32" Alias "GetComputerNameA" (ByVal sBuffer As String, lSize As Long) As Long

Type DISK_STRUCT
	DiskName As String						'Stores Name of Disk e.g  "C:", "D:".
	ThresUtil As Double						'Threshold for the Disk Utilisation, When utilisation exceeds this value an Event is Fired.
	ThresFree As Double						'Threshold for the Free disk space, When Free disk space is below this value an Event is Fired.
	CurrentUtil As Double					'Current Utilisation, this is gathers from the Managed Objects.
	CurrentFree As Double					'Current free space, this is gathers from the Managed Objects.
	ThreshCountAbove As Integer				'Count for amount of times a threshold must be broken consecutively before an event is fired.
	ThreshCountBelow As Integer				'Count for amount of times the values are below the thresholds consecutively before an event is fired.
	EventFired As Boolean					'Stores whether an event has been fired, this is set to "False" initially, this stops the script 
											'      from sending a "Normal" mesaage when it first starts up (This causes Command post To be out of sync)
End Type

Dim Version As String
Dim NT As Object 					'Used to reference the NT Counters
Dim OBJ As Object 					'Used to access Disk information
Dim DiskArray() As DISK_STRUCT		'An Array of Disks
Dim NewDisks () As DISK_STRUCT		'An Array of Temporary Disks
Dim NoofInteration As Long		'Stores the Iteration count, This removes need to continually call IterationsCount() procedure.
Dim KSName As String



Const UNITPERCENT = "^^%"			'Constants for Value Types , this is used for formatting output messages.
Const UNITMEGABYTE = "^^MB"


Function largeint2double (ByVal low As Long, ByVal high As Long) As Double
	Dim dlow As Double
	Dim dhigh As Double
	Dim t As Double

	If (low < 0) Then
		t = (low And &H7FFFFFFF)
		dlow = t + 2147483648.0
	Else
		dlow = low
	End If
	If (high < 0) Then
		t = (high And &H7FFFFFFF)
		dhigh = t + 2147483648.0
	Else
		dhigh = high
	End If
	largeint2double = dhigh * 4294967296.0 + dlow

End Function

Function GetVersionEx() As String
	Dim lRetVal&, hKey&, ValLen&, DataName$, DataLen&
	
	GetPlatformInfo = ""
        lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,_
         "SOFTWARE\Microsoft\Windows NT\CurrentVersion", 0, _
        KEY_READ, hKey)
	DataLen = 256
	DataName = String$(DataLen, 0)	
	lRetVal = RegQueryValueExString(hKey, "CurrentVersion", 0&, REG_SZ, DataName, DataLen)
	If (lRetVal <> ERROR_NONE) Then
		GoTo OUT
	End If
	DataName = Left$(DataName, DataLen-1)
	DataName = Trim$(DataName)
	GetVersionEx = DataName
OUT:
	lRetVal = RegCloseKey (hKey)
End Function

Function GetDisk(ByVal diskname As String, ByRef percentfree As Double, ByRef freemega As Double) As Long

	Dim FreeBytesAvailableToCaller As ULARGE_INTEGER
	Dim TotalNumberOfBytes As ULARGE_INTEGER
	Dim TotalNumberOfFreeBytes As ULARGE_INTEGER
	Dim dFreeBytesAvailableToCaller As Double
	Dim dlpTotalNumberOfBytes As Double
	Dim dTotalNumberOfFreeBytes As Double
	Dim rc As Long 
    Dim SecPerClu As Long
    Dim BytesPerSe As Long
    Dim NumOfFreeClu As Long
    Dim TotalNumOfClu As Long

	rc = GetDiskFreeSpaceEx(diskname, FreeBytesAvailableToCaller, TotalNumberOfBytes, TotalNumberOfFreeBytes)
	If (rc = 0) Then
		percentfree = -1 
		freemega= -1
		GetDisk = -1
		' un-comment out the following two lines if you want the KS to abort  
		'Err.Description = "Failed on GetFreeDiskSpaceEx."
		'Err.raise 4110	  'raise error to terminate this KS

	Else
		dTotalNumberOfBytes = largeint2double(TotalNumberOfBytes.LowPart, TotalNumberOfBytes.HighPart)
		dTotalNumberOfFreeBytes = largeint2double(TotalNumberOfFreeBytes.LowPart, TotalNumberOfFreeBytes.HighPart)
		percentfree = (dTotalNumberOfFreeBytes/dTotalNumberOfBytes)*100.0
		freemega = dTotalNumberOfFreeBytes/1048576.0 
		GetDisk = 0
    End If

End Function

'This function is required to replace characters in a string with a different Character.
'In this Script this function is used to replace spaces , " " , with hyphen's ,"-"
Function AlterString(sString As String, sCharToReplace As String, sCharToReplaceWith As String) As String

    Dim nLen As Long
    Dim sTemp As String
    Dim sTemp1 As String
    Dim I As Long
    
    nLen = Len(sString)
    
    For I = 1 To nLen
        sTemp = Mid(sString, I, 1)
        If sTemp = sCharToReplace Then
            sTemp = sCharToReplaceWith
        End If
        sTemp1 = sTemp1 + sTemp
    Next I
    AlterString = sTemp1
    
End Function




'Used to create Debug Directory, if it does not exist.
'This is a seperate function so that "On Error Resume Next" can be used for just this code.
Function createdebugdir() As Integer
	On Error Resume Next

	Dim dirname As String 
	dirname = "c:\NetIQ_KSdebug\"

	MkDir dirname
	If Err <> 0 Then
		createdebugdir = Err
	Else
		createdebugdir = 0
	End If

End Function


'This Function is required to create the structures for each disk, and assign the values for each disk
Sub CreateDiskArray ()

	Dim DiskCount As Integer	'used to count number of disks
	Dim ObjName As String		'Stores the name of the Object being referenced
	Dim I As Integer			'Used to loop through the list of objects stored in NT_LogicalDiskObj, 
								'   this is created when the script is dropped on a collection of disks and can be used to know 
								'	how many disks need to be checked, this allows for single or groups of disks.
	Dim J As Integer			'This is used to cycle through the Disk info provided in the Parameters Dialog Box.
	Dim DUtil As Double			'Used to store the disk utilisation (Calculated from Free Space and Utilisation)
	Dim DFree As Double			'Used to store the disk free space (read from Management Objects)
	Dim DUsed As Double			'Used to store the disk used space (read from Management Objects)
	Dim Count As Integer		'Used to cycle through disk objects
	Dim NewCount As Integer		'Count of Disks
	Dim NewDiskCount As Integer	'Used to store number of disks is a new Object to manage is found
	Dim rc As Integer			'Checks if Counter/API returned Value

	On Error GoTo HANDEL_ERROR



	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then
		createret = createdebugdir	'Use Function to Create Directory if its not already there
		Open "c:\NetIQ_KSdebug\" & KSName & ".txt" For Append Access Write As #2
	End If

	'Count Number of Disks that the Script has been dropped on
	DiskCount = ItemCount(NT_LogicalDiskObj, ",")
	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then 
		Print #2, now() & "       " & "Creating Disk Array"
		Print #2, now() & "       " & ""
		Print #2, now() & "       " & "The number of Objects to analyse is : " & DiskCount
		Print #2, now() & "       " & ""
	End If
	'If this is the first time for the script then the Array Storing Disk info is resized, 
	'there will be no data so no need to preserve structure.
	If NoofInteration = 1 Then
		If Ucase(debug) = "Y" Then 
			Print #2, now() & "       " & "Redimensioning array as this is the First iteration"
		End If
		ReDim DiskArray(DiskCount)
	Else	
		If Ucase(debug) = "Y" Then 
			Print #2, now() & "       " & "Redimensioning array and preserving existing info as this is not the First iteration"
		End If

		ReDim Preserve DiskArray(DiskCount) 'Otherwise Preserve data stored in array.
	End If

	'Cycle through the disks that the script has been dropped on.
	For I = 0 To DiskCount - 1 
		'Get Object to look at from the object list
		ObjName = Item$(NT_LogicalDiskObj, I + 1,, ",")	
	
		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then Print #2, now() & "       " &  "Analysing object : " & ObjName
 	
		'Get Counter Values from the Management Objects

        If (Version >= NT_MajorVersion_40) Then
		    rc = GetDisk(objname, Dutil, Dfree)
			If Ucase(debug) = "Y" Then 
				Print #2, now() & "       " & "Counters Retrieved using API"
				Print #2, now() & "       " & "Counter for % free space returned " & DUtil
				Print #2, now() & "       " & "Counter for free space returned " & DFree
			End If
        Else
			rc = 0
 	        'call the counter-based MOs below
		    Dutil = Obj.CounterValue("LogicalDisk", "% Free Space", objname)
		    Dfree = Obj.CounterValue("LogicalDisk", "Free Megabytes", objname)
			If Ucase(debug) = "Y" Then 
				Print #2, now() & "       " & "Counters Retrieved using Perfmon Counters"
				Print #2, now() & "       " & "Counter for % free space returned " & DUtil
				Print #2, now() & "       " & "Counter for free space returned " & DFree
			End If
		    If Dutil = -1 Or Dfree = -1 Then						'exit if error in calling the MO
				rc = -1
				' un-comment out the following two lines if you don't want the KS to abort
				'Err.Description = "Failed on Counter/LDisk MO."
				'Err.raise 4110	  'raise error to terminate this KS
		    End If
        End If

		If rc = -1 Then 
			If DUtil = -1 Then						'exit if error in calling the MO
				If Ucase(debug) = "Y" Then 
					Print #2, now() & "       " & "Failed to get counter value for DUtil"
					Close #2
				End If
				detailmsg = "Failed on Counter/LDisk MO."
				MCAbort ObjName, detailmsg
			End If
		
			If DFree = -1 Then						'exit if error in calling the MO
				If Ucase(debug) = "Y" Then 
					Print #2, now() & "       " & "Failed to get counter value for DFree"
					Close #2
				End If
				detailmsg = "Failed on Counter/LDisk MO."
				MCAbort ObjName, detailmsg
			End If
		End If

		If DUtil <> 0 Then
			DUsed = ((DFree * 100) / DUtil) - DFree			'get the used MB
		Else
			DUsed = -1		' currently we didn't get total disk space from MO
		End If
		DUtil = 100 - DUtil	'get the used space %

		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then Print #2, now() & "       " & "Object Utilisation : " & DUtil

		'If First Iteration, then all the data from the Parameters screen is put into the Disk Array
		If NoofInteration = 1 Then	
			If Ucase(debug) = "Y" Then 
				Print #2, now() & "       " & "First iteration so parameters are assigned to new disks"
			End If
			
			If Ucase(debug) = "Y" Then 
				Print #2, now() & "       "
				Print #2, now() & "       " & "Assign Disk name " & ObjName & " to diskarray element " & I
				Print #2, now() & "       "
			End If
			'Assign Disk Name
			DiskArray(I).DiskName = ObjName	
			For J = 1 To ItemCount(DISKS, ",")	
				If UCase$(ObjName) = UCase$(Item$(DISKS, J,, ",") & ":") Then
					'Assign Threshold for Utilisation if an entry is on the parameters screen for this object
			   		DiskArray(I).ThresUtil = CDbl(item$(TH_UTIL, J,, ","))  
					'Assign Threshold for Free space if an entry is on the parameters screen for this object
					DiskArray(I).ThresFree = CDbl(item$(TH_FREE, J,, ","))
					Exit For
				Else
					'If there is no paramater use the Default Value's for this object
			   		DiskArray(I).ThresUtil = DEF_UTIL
					DiskArray(I).ThresFree = DEF_FREE			
				End If
			Next J

			'Reset the Count of occurences above the threshold
			DiskArray(I).ThreshCountAbove = 0 
			'Reset the Count of occurences below the threshold
			DiskArray(I).ThreshCountBelow = 0 
			'Assign the Current Utilisation to the Disk Array element
			DiskArray(I).CurrentUtil = Dutil
			'Assign the Current free space to the Disk Array element
			DiskArray(I).CurrentFree = DFree
			'As this is the first iteration no events have been fired so the is set to "false".
			DiskArray(I).EventFired="False"
		Else
			'if this is not the first iteartion then the Array elements are updated with the current values.
			If Ucase(debug) = "Y" Then 
				Print #2, now() & "       " & "Not first iteration so old disk objects are updated with the current parameters"
			End If

			Count = UBound(DiskArray)
			For J = 0 To Count
				'if a disk is specified in the parameters but does not exist on the system, it's name will be null at this point
				'so it will not match and therfore it will not be copied to the new disk structure
				If UCase$(ObjName) = UCase$(DiskArray(J).DiskName) Then
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & "Disk has been found in old disk array"
					End If
					DiskArray(J).CurrentUtil = Dutil
					DiskArray(J).CurrentFree = DFree
					ReDim Preserve NewDisks(NewCount)
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & "Number of disk in old array : " & UBound(DiskArray)
						Print #2, now() & "       " & "Number of disk in new array : " & UBound(Newdisks)
					End If
					NewDisks(NewCount).DiskName = DiskArray(J).DiskName
					NewDisks(NewCount).ThresUtil = DiskArray(J).ThresUtil
					NewDisks(NewCount).ThresFree = DiskArray(J).ThresFree
					NewDisks(NewCount).CurrentUtil = DiskArray(J).CurrentUtil
					NewDisks(NewCount).CurrentFree = DiskArray(J).CurrentFree
					NewDisks(NewCount).ThreshCountAbove = DiskArray(J).ThreshCountAbove
					NewDisks(NewCount).ThreshCountBelow	= DiskArray(J).ThreshCountBelow
					NewDisks(NewCount).EventFired = DiskArray(J).EventFired 
					NewCount = NewCount + 1
				End If
			Next J
			' If the Object does not exist then the parameters screen has been updated and the the Disk array structure
			' Has another element added for this new object. This allows historical data to be kept but a new disk added
			' to the monitoring.
			If (Not Exists(ObjName)) Then
				If Ucase(debug) = "Y" Then 
					Print #2, now() & "       " & "Disk not found, try to create in new disk array"
				End If

				NewDiskCount = UBound(NewDisks)				
				If Err.Number = 9 Then
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & "New disk array does not exist"
					End If
					NewDiskCount = 0				
				Else
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & "Increment number of new disks by one"
					End If
					NewDiskCount = NewNewCount + 1
				End If
				NewCount = NewDiskCount + 1
				ReDim Preserve NewDisks(NewDiskCount)
				NewDisks(NewDiskCount).DiskName = ObjName
				NewDisks(NewDiskCount).CurrentUtil = Dutil
				NewDisks(NewDiskCount).CurrentFree = DFree
				'Assign the values from the parameters screen or use the default values.
				For J = 1 To ItemCount(DISKS, ",")	
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & "Assign paramaters for new disk"
					End If

					If UCase$(ObjName) = UCase$(Item$(DISKS, J,, ",") & ":") Then
				   		NewDisks(NewDiskCount).ThresUtil = CDbl(item$(TH_UTIL, J,, ","))
						NewDisks(NewDiskCount).ThresFree = CDbl(item$(TH_FREE, J,, ","))
						Exit For
					Else
				   		NewDisks(NewDiskCount).ThresUtil = DEF_UTIL
						NewDisks(NewDiskCount).ThresFree = DEF_FREE			
					End If
				Next J
			End If
		End If



		If NoofInteration = 1 And DO_DATA = "y" Then		  	'set up during 1st iteration
			DataHeader "Ldsk: " & ObjName & "USED" & UNITPERCENT, 0, I	'the 1st data stream
			DataHeader "Ldsk: " & ObjName & "AVAIL" & UNITMEGABYTE, 0, I+1000	'the 2nd data stream
		End If
		If DO_DATA = "y" Then							'data collection requested
			Dim datapoint$
			If Dused <> -1 Then
				datapoint = "Used %= " & Format$(Dutil, "0.00") & chr$(10) & _ 'build intelligent data point
					 "Avail %= " & Format$(100 - Dutil, "0.00") & chr$(10) & _
				 	 "Used space MB = " & CStr(Dused)	& chr$(10) & _
				 	 "Free space MB = " & CStr(Dfree)	& chr$(10)
	    	Else
				datapoint = "Used %= " & Format$(Dutil, "0.00") & chr$(10) & _ 'build intelligent data point
					 "Avail %= " & Format$(100 - Dutil, "0.00") & chr$(10) & _ ' "Used space MB = " & CStr(Dused)	& chr$(10) & _
				 	 "Free space MB = " & CStr(Dfree)	& chr$(10)
			End If
		    DataLog I, Dutil, datapoint					'colelct data fro 1st data stream
	        DataLog I+1000, Dfree, datapoint					'collect data for 2nd  data stream
		End If
		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then 
			Print #2, now() & "       " & "Object Name				: " & DiskArray(I).DiskName
			Print #2, now() & "       " & "		Utilisation Threshold	: " & DiskArray(I).ThresUtil
			Print #2, now() & "       " & "		Current Utilisation  	: " & DiskArray(I).CurrentUtil
			Print #2, now() & "       " & "		Free Space  Threshold	: " & DiskArray(I).ThresFree
			Print #2, now() & "       " & "		Current Free Space  	: " & DiskArray(I).CurrentFree
		End If	

	Next I
If Ucase(debug) = "Y" Then Close #2

Exit Sub

HANDEL_ERROR:

'If array element is not found Err.Number 9 is raised.
If Err.Number = 9 Then
	Resume Next
End If
Close #2
End Sub

'This function moves all the disk array sturctures into one place, if for example a new disk is
'Added the new disk must be included in the DiskArray() Array.
Sub SwappArrays()
	If Ucase(debug) = "Y" Then 
		createret = createdebugdir	'Use Function to Create Directory if its not already there
		Open "c:\NetIQ_KSdebug\" & KSName & ".txt" For Append Access Write As #2
	End If
	Dim QCount As Long
	Dim I As Long

	If Ucase(debug) = "Y" Then 
		Print #2, now() & "       " & "Swap disk arrays from new disk to current disks"
	End If
		
	If NoofInteration <> 1 Then

		QCount = UBound(NewDisks)
		If Ucase(debug) = "Y" Then 
			Print #2, now() & "       " & "This is iteration " & NoofInteration
			Print #2, now() & "       " & "Number of disks in new array is " & QCount
			Print #2, now() & "       " & "Assign new disk array elements to old disk array"
		End If

		ReDim DiskArray(QCount) 
		For I = 0 To QCount
			DiskArray(I).DiskName = NewDisks(I).DiskName
			DiskArray(I).ThresUtil = NewDisks(I).ThresUtil
			DiskArray(I).ThresFree = NewDisks(I).ThresFree
			DiskArray(I).CurrentUtil = NewDisks(I).CurrentUtil
			DiskArray(I).CurrentFree = NewDisks(I).CurrentFree
			DiskArray(I).ThreshCountAbove = NewDisks(I).ThreshCountAbove
			DiskArray(I).ThreshCountBelow = NewDisks(I).ThreshCountBelow
			DiskArray(I).EventFired = NewDisks(I).EventFired
		Next I
		ReDim NewDisks(0)
	End If
	
If Ucase(debug) = "Y" Then 
	Close #2
End If

End Sub



'In this sub routine if the counter values fall below the thresholds supplied for a certain number of times
'an event is fired off. If the values are below the thresholds for a certain number of times and an event has been fired
'another event will be raised to notify that the values have returned to a normal state. This logic is there to stop the
'script from sending an event saying that everything is normal as soon as the script starts. This is needed to allow the
'command post system to be kept in sync when events occur and are then fixed.
Sub DisplayEvent()


	Dim Count As Long	
	Dim LongMsg As String
	Dim ShortMsg As String
	Dim ResName As String
	Dim I As Long
    Dim NameSize As Long
    Dim X As Long
	Dim Machinename1 As String
	Dim Machinenamestr As String
	Dim y As Integer
    MachineName1 = Space$(16)
    NameSize = Len(MachineName1)
    X = GetComputerName(Machinename1,NameSize)
	For y = 1 To Len(Machinename1)
		If ASC(Mid(Machinename1,y,1)) <> 0 Then
			Machinenamestr = Machinenamestr + Mid(Machinename1,y,1)
		End If
	Next y
	Machinenamestr = lcase(trim(Machinenamestr))
	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then 
		createret = createdebugdir	'Use Function to Create Directory if its not already there
		Open "c:\NetIQ_KSdebug\" & KSName & ".txt" For Append Access Write As #2
		Print #2, now() & "       " &  ""
		Print #2, now() & "       " &  ""
		Print #2, now() & "       " &  ""
	End If

	Count = UBound(DiskArray)
	If Err.Number = 9 Then
		If Ucase(debug) = "Y" Then Print #2, now() & "       " & " There are no DiskArrays Defined"
	End If


	'Cycle through each disk.
	For I = 0 To Count		 
		'Get disk name from Array structure.
		ResName = "NT_LogicalDiskObj = " & DiskArray(I).DiskName
	
		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then 
			Print #2, now() & "       " &  ""
			Print #2, now() & "       " &  ""
			Print #2, now() & "       " &  " Disk name                        : " & DiskArray(I).DiskName
			Print #2, now() & "       " &  " Event Already                    : " & DiskArray(I).EventFired
			Print #2, now() & "       " &  " This is the Number of Iterations : " & NoofInteration
			Print #2, now() & "       " &  ""
		End If

		'If the Thresholds for either Utilisation or free space are breached and DO_EVENTS is set to "y" then either an event is fired or
		'if the number of times are not enough then a counter is increased
		If DO_EVENT = "y" And DiskArray(I).CurrentUtil > DiskArray(I).ThresUtil Or DiskArray(I).CurrentFree < DiskArray(I).ThresFree  Then
			
			DiskArray(I).ThreshCountAbove = DiskArray(I).ThreshCountAbove + 1

			'If debugging is enabled information is written to a text file
			If Ucase(debug) = "Y" Then 
				Print #2, now() & "       " & ""
				Print #2, now() & "       " & ""
				Print #2, now() & "       " & " Current Utilisation or free space over threshold ThreshCountAbove : " & DiskArray(I).ThreshCountAbove
			End If

			' this checks whether this event has occured the required number of times for an event to be fired
			If DiskArray(I).ThreshCountAbove >= CONSEC_TIME_ABOVE Then 
				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2, now() & "       " & ""
					Print #2, now() & "       " & " This event has now occured consequtively the CONSEC_TIME_ABOVE number of times"
					Print #2, now() & "       " & " We have now seen the event " & CONSEC_TIME_ABOVE & " Times"
					Print #2, now() & "       " & ""	
					Print #2, now() & "       " & ""	
				End If

				'This checks to see if the Utilisation is the reason 
				If DiskArray(I).CurrentUtil > DiskArray(I).ThresUtil Then
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & ""
						Print #2, now() & "       " & " Current Utilisation is above Threshold on Drive : " & DiskArray(I).DiskName
						Print #2, now() & "       " & ""	
					End If

					'if it is than a message is built up stating this
					LongMsg = "Disk "  &  DiskArray(I).DiskName & " Used % is " & Format$(DiskArray(I).CurrentUtil, "0.00") & "; >TH = " & CStr(DiskArray(I).ThresUtil) & chr$(10)
					ShortMsg = Format$(DiskArray(I).CurrentUtil, "0.00") & "%"

				End If

				'This checks to see if the free space is the reason 
				If DiskArray(I).CurrentFree < DiskArray(I).ThresFree Then
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & ""
						Print #2, now() & "       " & " Current Free Space is Below Threshold on Drive : " & DiskArray(I).DiskName
						Print #2, now() & "       " & ""	
					End If


					LongMsg = LongMsg &	"Free space MB is " & Format$(DiskArray(I).CurrentFree, "0.00") & "; <TH = " & CStr(DiskArray(I).ThresFree)
					If ShortMsg <> "" Then
						ShortMsg = ShortMsg & "-" & Format$(DiskArray(I).CurrentFree, "0.00") & "MB"
					Else
						ShortMsg = Format$(DiskArray(I).CurrentFree, "0.00") & "MB"
					End If
				End If

				' for Command post messages the message should not conatin spaces, so these are replaced with hyphens
				If DO_NUMBERS = "y" Then
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & ""
						Print #2, now() & "       " & " Do Numbers is True"
						Print #2, now() & "       " & ""	
					End If

					ShortMsg = MachineNamestr & " " & trim(DiskArray(I).DiskName) & " FULL" & " " & ShortMsg
				Else
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2, now() & "       " & ""
						Print #2, now() & "       " & " Do Numbers is False"
						Print #2, now() & "       " & ""	
					End If
					' for Command post messages the message should not conatin spaces, so these are replaced with hyphens
					ShortMsg = MachineNamestr & " " & trim(DiskArray(I).DiskName) & " FULL" & " " & " NULL"
				End If				
				' Send message using whatever method the Script has bee setup to use
				MSActions SEVERITY, ShortMsg, AKPID, ResName, LongMsg
				'once a message has been sent the counters must be reset so that another occurence can be monitored.
				'DiskArray(I).ThreshCountBelow=0
				DiskArray(I).ThreshCountAbove=0
				'This is used for firing another event if the thresholds are not breached.
				DiskArray(I).EventFired= "True"

				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2, now() & "       " & ""
					Print #2, now() & "       " & ""
					Print #2, now() & "       " & " Disk Name 						 : " & DiskArray(I).DiskName
					Print #2, now() & "       " & ""	
					Print #2, now() & "       " & " Short Message 					 : " & ShortMsg
					Print #2, now() & "       " & ""	
					Print #2, now() & "       " & " Long Message 					 : " & LongMsg
					Print #2, now() & "       " & ""				
					Print #2, now() & "       " & ""		
				End If		
			Else

			End If
		'This section is run if the counters are not over the thresholds, this also must be checked as another message
		'may need to be sent to tell command post that the problem has been resolved.
		ElseIf DO_EVENT = "y" And DiskArray(I).CurrentUtil < DiskArray(I).ThresUtil Or DiskArray(I).CurrentFree > DiskArray(I).ThresFree Then
			'If debugging is enabled information is written to a text file
			If Ucase(debug) = "Y" Then 
				Print #2, now() & "       " & ""
				Print #2, now() & "       " & ""
				Print #2, now() & "       " & " Current Utilisation or free space below threshold ThreshCountBelow : " & DiskArray(I).ThreshCountBelow
				Print #2, now() & "       " & ""
			End If
			'If this section is run then the thresholds have not been breached this time so the couter for how many time they 
			'have been breached is set to 0
			'DiskArray(I).ThreshCountAbove = 0

			'Only if an event has been fored for this object will this section run, eventfired= true, this stops the event being fired 
			'when the script starts
 			If DiskArray(I).EventFired= "True" And DiskArray(I).ThreshCountBelow >= CONSEC_TIME_BELOW Then
				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2, now() & "       " & ""
					Print #2, now() & "       " & " This Section Only Occurs if an Event for Count above CONSEC_TIME_ABOVE has fired and the number"
					Print #2, now() & "       " & " Of Clear Events is = CONSEC_TIME_BELOW value "	
					Print #2, now() & "       " & ""
				End If
				'Build normal message
				LongMsg = "Disk "  &  DiskArray(I).DiskName & " Used % is " & Format$(DiskArray(I).CurrentUtil, "0.00") & "; <TH = " & CStr(DiskArray(I).ThresUtil) & chr$(10)
				LongMsg = LongMsg &	"Free space MB is " & Format$(DiskArray(I).CurrentFree, "0.00") & "; >TH = " & CStr(DiskArray(I).ThresFree)
				ShortMsg = Format$(DiskArray(I).CurrentUtil, "0.00") & "%-" & Format$(DiskArray(I).CurrentFree, "0.00") & "MB"
				' for Command post messages the message should not conatin spaces, so these are replaced with hyphens
				If DO_NUMBERS = "y" Then
					ShortMsg = MachineNamestr & " " & trim(DiskArray(I).DiskName) & " NORMAL" & " " & ShortMsg					
					If Ucase(debug) = "Y" Then Print #2, now() & "       " & ""
					If Ucase(debug) = "Y" Then Print #2, now() & "       " &  shortmsg
					If Ucase(debug) = "Y" Then Print #2, now() & "       " & ""	
				Else
					ShortMsg = MachineNamestr & " " & trim(DiskArray(I).DiskName) & " NORMAL" 
					If Ucase(debug) = "Y" Then Print #2, now() & "       " & ""
					If Ucase(debug) = "Y" Then Print #2, now() & "       " &  shortmsg
					If Ucase(debug) = "Y" Then Print #2, now() & "       " & ""	
				End If
				'Send message
				If SEND_NORMAL = "y" Then
					If Ucase(debug) = "Y" Then Print #2, now() & "       " & "Send Auto Clear"	
					MSActions 40, ShortMsg, AKPID, ResName, LongMsg
				Else
					If Ucase(debug) = "Y" Then Print #2, now() & "       " & "AKPID = "	& AKPID & "  Left(AKPID,17) = " & Mid(AKPID,instr(1,AKPID,"A"),17)
					If Mid(AKPID,instr(1,AKPID,"A"),17) = "ACTION_SSICmdPost" Then
						MSActions 40, ShortMsg, AKPID, ResName, LongMsg
						If Ucase(debug) = "Y" Then Print #2, now() & "       " & "Action is Command Post so send Auto Clear anyway"	
					Else
						If Ucase(debug) = "Y" Then Print #2, now() & "       " & "Do Not Send Auto Clear"	
					End If
				End If
				'once event has been fired it does not need to be sent again 				
				DiskArray(I).ThreshCountBelow = 0
				DiskArray(I).EventFired= "False"
				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2, now() & "       " & ""
					Print #2, now() & "       " & " Disk Name 						 : " & DiskArray(I).DiskName
					Print #2, now() & "       " & ""	
					Print #2, now() & "       " & " Short Message 					 : " & ShortMsg
					Print #2, now() & "       " & ""	
					Print #2, now() & "       " & " Long Message 					 : " & LongMsg
					Print #2, now() & "       " & ""				
					Print #2, now() & "       " & ""				
				End If
			Else
				'otherwise this is another below threshold message so increment the counter until it gets to the point when the event is fired.
				'If statement limits the number of threshold below messages, so that Overflow does not occur if disk is below threshold for
				'more than 16385 times (limit for integer variables)
				If DiskArray(I).ThreshCountBelow < 1000 Then
					DiskArray(I).ThreshCountBelow = DiskArray(I).ThreshCountBelow +1
				End If
			End If
		End If
	Next I
If Ucase(debug) = "Y" Then 
	 Close #2
End If
End Sub


'this checks to see if any of the object names match the value that is passed in
Function Exists(ByRef sDisk As String) As Variant
	
	Dim nDiskCount As Integer
	Dim I As Integer
	nDiskCount = UBound(DiskArray)

	Exists = False
	For I = 0 To nDiskCount
		If sDisk = DiskArray(I).DiskName Then
			Exists = True
			Exit For
		End If
	Next I

End Function


Sub Main()

	'This assigns the object that need to be read
	Set NT = CreateObject("NetiQAgent.NT")
	Set OBJ = NT.System
	'Setup the variable storing the number of times the script has been run.
	NoofInteration = Iterationcount()
	KSName = "NT_SSILogicalDiskSpace"

	If NoofInteration = 1 Then
        Version = GetVersionEx()
	End If
	'If debugging is enabled information is written to a text file	
	If Ucase(debug) = "Y" Then
		createret = createdebugdir	'Use Function to Create Directory if its not already there
		If FileExists("c:\NetIQ_KSdebug\" & KSName & ".txt") Then

			If filelen("c:\NetIQ_KSdebug\" & KSName & ".txt") > 512000 Then

				If FileExists("c:\NetIQ_KSdebug\" & KSName & ".old") Then
					kill "c:\NetIQ_KSdebug\" & KSName & ".old"
				End If

				Name "c:\NetIQ_KSdebug\" & KSName & ".txt" As "c:\NetIQ_KSdebug\" & KSName & ".old"

			End If
		End If
		Open "c:\NetIQ_KSdebug\" & KSName & ".txt" For Append Access Write As #2
		Print #2, now() & "       " &  ""
		Print #2, now() & "       " &  "****************************************************************************"
		Print #2, now() & "       " &  " Start of iteration " & NoofInteration
		Print #2, now() & "       " &  ""
		Close #2
	End If

	' Create a array of all disks and their thresholds limits to accomodate for both MB free and % used

	CreateDiskArray

	' Swapp DiskArray with the NewDiska Array

	SwappArrays

	' Display events 

	DisplayEvent

	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then
		Open "c:\NetIQ_KSdebug\" & KSName & ".txt" For Append Access Write As #2
		Print #2, now() & "       " &  " End of iteration " & NoofInteration
		Print #2, now() & "       " &  "****************************************************************************"
		Print #2, now() & "       " &  ""
		Close #2
	End If

End Sub


'### End KPS Section


