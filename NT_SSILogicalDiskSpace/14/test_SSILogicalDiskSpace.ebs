'### This is an .ebs file generated by KSCheckout.
'### It can be checked in to the repository by invoking kscheckin.
'###
'### NT_SSILogicalDiskSpace

'### Begin KP-Status Section
'NeedKPW = 0
'AdminOnly = 0
'DisplayToolBar = 1
'IAmDiscovery = 0
'IAmAction = 0
'Description = Monitor if the Logical Disk(s) is getting full

'### End KP-Status Section

'### Begin KPC Section
'Parameters = 0 128 0 8 24 0 0 2147483647 0 99991231 0 235959

'### End KPC Section

'### Begin Type Section
Const NT_LogicalDiskObj = ""

'### End Type Section

'### Begin KPP Section

'### Author 		: NetIQ
'### Version		: 1.1
'### Description	: Monitors Logical Disk Space 

'### Changed by		: Dayanand Sankar (713) 245-1556 (Property of Shell Services International)
'### Date			: 7/29/97
'### Revision       : 1.1
'### Enhancements 	: -Change to fix false alerts  

'### Changed by		: Dayanand Sankar (713) 245-1556 (Property of Shell Services International)
'### Date			: 6/5/97
'### Revision       : 1.2
'### Enhancements 	: -Change to accomodate 'n' consecutive times of occurrences for disk space exceeding thresholds
'###				  -Initial Clear message and Clear message after a threshold has been 
'###				   reached and then falling below that threshold 'n' consecutive times.
'###				  -Also event messages are formatted to represent 
'###				   Counter, Value and Number with only spaces seperating these three entities.
'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 2/10/97
'### Revision       : 1.3
'### Enhancements 	: -Changed Logic as events were only fired once in previous revision.
'###				  -Added EventFired Property to DISK_STRUCT, this allows Normal Event only to be fired if				  
'###				   an event has previously been fired to say that the thresholds have been breached. This 				  
'###				   allows the Command Post to match up the Events correctly.				  
'###				  -Added Debug Switch to output value to Text File.				  
'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 3/10/97
'### Revision       : 1.4
'### Enhancements 	: -Removed Excess Logic for determining when events will fire
'###				  -Added Parameters to allow user to specify different n Occurence values
'###				   for when the Events will fire for being over the thresholds and when the Event
'###				   will fire for Normal operation again. This changes one paramater Threscount to be
'###				   ThresCountAbove and ThresCountBelow.
'###				  -Commented the Script, through out.
'### Changed by		: Paul Curtis (171) 257-7373 (Property of Shell Services International)
'### Date			: 3/10/97
'### Revision       : 1.5
'### Enhancements 	: -Changed Logic for "N" consecutive times, for logic for "N" Occurrence.

'[V<CPReady. Disk Util monitors the disk space usage (in %). Free Space indicates the space free (in MB). Event is raised if ANY disk's usage is over Max Disk Utilization (%) OR the free space is below Min Free Space (MB). (Version 1.4)>V]

Const DO_EVENT = "y"			'[M<Event? (y/n)>M] [T<String,1,,"yn">T]
Const DO_DATA = "n"				'[M<Collect Data? (y/n)>M] [T<String,100,,"yn">T]
Const DO_NUMBERS = "y" '[M<Show numbers? (y/n)>M][T<string,1,' ',yn">T]
Const DISKS = "C,D,E,F"			'[M<List Disks to Monitor separated by "," w/ no space.>M] [T<String,1000,',',>T]
Const TH_UTIL = "95,95,95,95"	'[M<Max Disk Utilization (%) limit for above disks separated by "," w/ no space.>M] [T<String,1000,',',>T]
Const TH_FREE = "10,10,10,10"	'[M<Min Free Space (MB) for above disks separated by "," w/ no space.>M] [T<String,1000,',',>T]
Const CONSEC_TIME_ABOVE = 3		'[M<Consecutive times above>M] [T<long,,,1, 999999, #>T]
Const CONSEC_TIME_BELOW = 3		'[M<Consecutive times below>M] [T<long,,,1, 999999, #>T]
Const DEF_UTIL = 95				'[M<Other Disk Util > >M] [T<Integer,,, 0, 100, %>T]
Const DEF_FREE = 10				'[M<Other Disk Free Space < >M] [T<Integer,,, 0, 9999, MB>T]
Const Severity = 8				'[M<Event Severity>M] [T<Integer,,,1, 40, SevLevel>T]
Const Debug = "n"			'[M<Debug to c:\logdisk.txt? (y/n)>M] [T<String,1,,"yn">T]

'[A<When the disk space is getting full, the selected action is taken.>A]
Const AKPID = "AKP_NULL"	' [M<Action Taken>M]

'### End KPP Section

'### Begin KPS Section

Type DISK_STRUCT
	DiskName As String						'Stores Name of Disk e.g  "C:", "D:".
	ThresUtil As Double						'Threshold for the Disk Utilisation, When utilisation exceeds this value an Event is Fired.
	ThresFree As Double						'Threshold for the Free disk space, When Free disk space is below this value an Event is Fired.
	CurrentUtil As Double					'Current Utilisation, this is gathers from the Managed Objects.
	CurrentFree As Double					'Current free space, this is gathers from the Managed Objects.
	ThreshCountAbove As Integer				'Count for amount of times a threshold must be broken consecutively before an event is fired.
	ThreshCountBelow As Integer				'Count for amount of times the values are below the thresholds consecutively before an event is fired.
	EventFired As Boolean					'Stores whether an event has been fired, this is set to "False" initially, this stops the script 
											'      from sending a "Normal" mesaage when it first starts up (This causes Command post To be out of sync)
End Type


Dim NT As Object 					'Used to reference the NT Counters
Dim OBJ As Object 					'Used to access Disk information
Dim DiskArray() As DISK_STRUCT		'An Array of Disks
Dim NewDisks () As DISK_STRUCT		'An Array of Temporary Disks
Dim NoofInteration As Integer		'Stores the Iteration count, This removes need to continually call IterationsCount() procedure.



Const UNITPERCENT = "^^%"			'Constants for Value Types , this is used for formatting output messages.
Const UNITMEGABYTE = "^^MB"


'This function is required to replace characters in a string with a different Character.
'In this Script this function is used to replace spaces , " " , with hyphen's ,"-"
Function AlterString(sString As String, sCharToReplace As String, sCharToReplaceWith As String) As String

    Dim nLen As Long
    Dim sTemp As String
    Dim sTemp1 As String
    Dim I As Long
    
    nLen = Len(sString)
    
    For I = 1 To nLen
        sTemp = Mid(sString, I, 1)
        If sTemp = sCharToReplace Then
            sTemp = sCharToReplaceWith
        End If
        sTemp1 = sTemp1 + sTemp
    Next I
    AlterString = sTemp1
    
End Function


'This Function is required to create the structures for each disk, and assign the values for each disk
Sub CreateDiskArray ()

	Dim DiskCount As Integer	'used to count number of disks
	Dim ObjName As String		'Stores the name of the Object being referenced
	Dim I As Integer			'Used to loop through the list of objects stored in NT_LogicalDiskObj, 
								'   this is created when the script is dropped on a collection of disks and can be used to know 
								'	how many disks need to be checked, this allows for single or groups of disks.
	Dim J As Integer			'This is used to cycle through the Disk info provided in the Parameters Dialog Box.
	Dim DUtil As Double			'Used to store the disk utilisation (Calculated from Free Space and Utilisation)
	Dim DFree As Double			'Used to store the disk free space (read from Management Objects)
	Dim DUsed As Double			'Used to store the disk used space (read from Management Objects)
	Dim Count As Integer		'Used to cycle through disk objects
	Dim NewCount As Integer		'Count of Disks
	Dim NewDiskCount As Integer	'Used to store number of disks is a new Object to manage is found

	On Error GoTo HANDEL_ERROR

	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then
		Open "c:\logdisk.txt" For Append Access Write As #2
	End If

	'Count Number of Disks that the Script has been dropped on
	DiskCount = ItemCount(NT_LogicalDiskObj, ",")
	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then 
		Print #2, "Creating Disk Array"
		Print #2,""
		Print #2, "The number of Objects to analyse is : " & DiskCount
		Print #2,""
	End If
	'If this is the first time for the script then the Array Storing Disk info is resized, 
	'there will be no data so no need to preserve structure.
	If NoofInteration = 1 Then
		ReDim DiskArray(DiskCount)
	Else	
		ReDim Preserve DiskArray(DiskCount) 'Otherwise Preserve data stored in array.
	End If

	'Cycle through the disks that the script has been dropped on.
	For I = 0 To DiskCount - 1 
		'Get Object to look at from the object list
		ObjName = Item$(NT_LogicalDiskObj, I + 1,, ",")	
	
		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then Print #2, "Analysing object : " & ObjName
 	
		'Get Counter Values from the Management Objects 
		DUtil = Obj.CounterValue("LogicalDisk", "% Free Space", ObjName)
		DFree = Obj.CounterValue("LogicalDisk", "Free Megabytes", ObjName)

		If DUtil = -1 Or DFree = -1 Then						'exit if error in calling the MO
			Err.Description = "Failed on Counter/LDisk MO."
			Err.raise 4110	'raise error to terminate this KS
		End If
		If DUtil <> 0 Then
			DUsed = ((DFree * 100) / DUtil) - DFree			'get the used MB
		Else
			DUsed = -1		' currently we didn't get total disk space from MO
		End If
		DUtil = 100 - DUtil	'get the used space %

		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then Print #2, "Object Utilisation : " & DUtil

		'If First Iteration, then all the data from the Parameters screen is put into the Disk Array
		If NoofInteration = 1 Then	
			
			'Assign Disk Name
			DiskArray(I).DiskName = ObjName	

			For J = 1 To ItemCount(DISKS, ",")	
				If UCase$(ObjName) = UCase$(Item$(DISKS, J,, ",") & ":") Then
					'Assign Threshold for Utilisation if an entry is on the parameters screen for this object
			   		DiskArray(I).ThresUtil = CDbl(item$(TH_UTIL, J,, ","))  
					'Assign Threshold for Free space if an entry is on the parameters screen for this object
					DiskArray(I).ThresFree = CDbl(item$(TH_FREE, J,, ","))
					Exit For
				Else
					'If there is no paramater use the Default Value's for this object
			   		DiskArray(I).ThresUtil = DEF_UTIL
					DiskArray(I).ThresFree = DEF_FREE			
				End If
			Next J

			'Reset the Count of occurences above the threshold
			DiskArray(I).ThreshCountAbove = 0 
			'Reset the Count of occurences below the threshold
			DiskArray(I).ThreshCountBelow = 0 
			'Assign the Current Utilisation to the Disk Array element
			DiskArray(I).CurrentUtil = Dutil
			'Assign the Current free space to the Disk Array element
			DiskArray(I).CurrentFree = DFree
			'As this is the first iteration no events have been fired so the is set to "false".
			DiskArray(I).EventFired="False"
		Else
			'if this is not the first iteartion then the Array elements are updated with the current values.
			Count = UBound(DiskArray)
			For J = 0 To Count
				If UCase$(ObjName) = UCase$(DiskArray(J).DiskName) Then
					DiskArray(J).CurrentUtil = Dutil
					DiskArray(J).CurrentFree = DFree
					ReDim Preserve NewDisks(NewCount)
					NewDisks(NewCount).DiskName = DiskArray(J).DiskName
					NewDisks(NewCount).ThresUtil = DiskArray(J).ThresUtil
					NewDisks(NewCount).ThresFree = DiskArray(J).ThresFree
					NewDisks(NewCount).CurrentUtil = DiskArray(J).CurrentUtil
					NewDisks(NewCount).CurrentFree = DiskArray(J).CurrentFree
					NewDisks(NewCount).ThreshCountAbove = DiskArray(J).ThreshCountAbove
					NewDisks(NewCount).ThreshCountBelow	= DiskArray(J).ThreshCountBelow
					NewDisks(NewCount).EventFired = DiskArray(J).EventFired 
					NewCount = NewCount + 1
				End If
			Next J
			' If the Object does not exist then the parameters screen has been updated and the the Disk array structure
			' Has another element added for this new object. This allows historical data to be kept but a new disk added
			' to the monitoring.
			If (Not Exists(ObjName)) Then
				NewDiskCount = UBound(NewDisks)				
				If Err.Number = 9 Then
					NewDiskCount = 0				
				Else
					NewDiskCount = NewNewCount + 1
				End If
				NewCount = NewDiskCount + 1
				ReDim Preserve NewDisks(NewDiskCount)
				NewDisks(NewDiskCount).DiskName = ObjName
				NewDisks(NewDiskCount).CurrentUtil = Dutil
				NewDisks(NewDiskCount).CurrentFree = DFree
				'Assign the values from the parameters screen or use the default values.
				For J = 1 To ItemCount(DISKS, ",")	
					If UCase$(ObjName) = UCase$(Item$(DISKS, J,, ",") & ":") Then
				   		NewDisks(NewDiskCount).ThresUtil = CDbl(item$(TH_UTIL, J,, ","))
						NewDisks(NewDiskCount).ThresFree = CDbl(item$(TH_FREE, J,, ","))
						Exit For
					Else
				   		NewDisks(NewDiskCount).ThresUtil = DEF_UTIL
						NewDisks(NewDiskCount).ThresFree = DEF_FREE			
					End If
				Next J
			End If
		End If



		If NoofInteration = 1 And DO_DATA = "y" Then		  	'set up during 1st iteration
			DataHeader "Ldsk: " & ObjName & "USED" & UNITPERCENT, 0, I	'the 1st data stream
			DataHeader "Ldsk: " & ObjName & "AVAIL" & UNITMEGABYTE, 0, I+1000	'the 2nd data stream
		End If
		If DO_DATA = "y" Then							'data collection requested
			Dim datapoint$
			If Dused <> -1 Then
				datapoint = "Used %= " & Format$(Dutil, "0.00") & chr$(10) & _ 'build intelligent data point
					 "Avail %= " & Format$(100 - Dutil, "0.00") & chr$(10) & _
				 	 "Used space MB = " & CStr(Dused)	& chr$(10) & _
				 	 "Free space MB = " & CStr(Dfree)	& chr$(10)
	    	Else
				datapoint = "Used %= " & Format$(Dutil, "0.00") & chr$(10) & _ 'build intelligent data point
					 "Avail %= " & Format$(100 - Dutil, "0.00") & chr$(10) & _ ' "Used space MB = " & CStr(Dused)	& chr$(10) & _
				 	 "Free space MB = " & CStr(Dfree)	& chr$(10)
			End If
		    DataLog I, Dutil, datapoint					'colelct data fro 1st data stream
	        DataLog I+1000, Dfree, datapoint					'collect data for 2nd  data stream
		End If
		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then 
			Print #2,"Object Name					: " & DiskArray(I).DiskName
			Print #2,"		Utilisation Threshold	: " & DiskArray(I).ThresUtil
			Print #2,"		Current Utilisation  	: " & DiskArray(I).CurrentUtil
			Print #2,"		Free Space  Threshold	: " & DiskArray(I).ThresFree
			Print #2,"		Current Free Space  	: " & DiskArray(I).CurrentFree
		End If	

	Next I
If Ucase(debug) = "Y" Then Close #2

Exit Sub

HANDEL_ERROR:

'If array element is not found Err.Number 9 is raised.
If Err.Number = 9 Then
	Resume Next
End If
Close #2
End Sub

'This function moves all the disk array sturctures into one place, if for example a new disk is
'Added the new disk must be included in the DiskArray() Array.
Sub SwappArrays()

	Dim QCount As Long
	Dim I As Long
		
	If NoofInteration <> 1 Then
		QCount = UBound(NewDisks)
		ReDim DiskArray(QCount) 
		For I = 0 To QCount
			DiskArray(I).DiskName = NewDisks(I).DiskName
			DiskArray(I).ThresUtil = NewDisks(I).ThresUtil
			DiskArray(I).ThresFree = NewDisks(I).ThresFree
			DiskArray(I).CurrentUtil = NewDisks(I).CurrentUtil
			DiskArray(I).CurrentFree = NewDisks(I).CurrentFree
			DiskArray(I).ThreshCountAbove = NewDisks(I).ThreshCountAbove
			DiskArray(I).ThreshCountBelow = NewDisks(I).ThreshCountBelow
			DiskArray(I).EventFired = NewDisks(I).EventFired
		Next I
		ReDim NewDisks(0)
	End If
	
End Sub



'In this sub routine if the counter values fall below the thresholds supplied for a certain number of times
'an event is fired off. If the values are below the thresholds for a certain number of times and an event has been fired
'another event will be raised to notify that the values have returned to a normal state. This logic is there to stop the
'script from sending an event saying that everything is normal as soon as the script starts. This is needed to allow the
'command post system to be kept in sync when events occur and are then fixed.
Sub DisplayEvent()


	Dim Count As Long	
	Dim LongMsg As String
	Dim ShortMsg As String
	Dim ResName As String
	Dim I As Long

	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then 
		Open "c:\logdisk.txt" For Append Access Write As #2
		Print #2, ""
		Print #2, ""
		Print #2, ""
		Print #2, ""
	End If

	Count = UBound(DiskArray)
	If Err.Number = 9 Then
		If Ucase(debug) = "Y" Then Print #2," There are no DiskArrays Defined"
	End If


	'Cycle through each disk.
	For I = 0 To Count		 
		'Get disk name from Array structure.
		ResName = "NT_LogicalDiskObj = " & DiskArray(I).DiskName
	
		'If debugging is enabled information is written to a text file
		If Ucase(debug) = "Y" Then 
			Print #2, ""
			Print #2, ""
			Print #2, " Disk name                        : " & DiskArray(I).DiskName
			Print #2, " Event Already                    : " & DiskArray(I).EventFired
			Print #2, " This is the Number of Iterations : " & NoofInteration
			Print #2, ""
		End If

		'If the Thresholds for either Utilisation or free space are breached and DO_EVENTS is set to "y" then either an event is fired or
		'if the number of times are not enough then a counter is increased
		If DO_EVENT = "y" And DiskArray(I).CurrentUtil > DiskArray(I).ThresUtil Or DiskArray(I).CurrentFree < DiskArray(I).ThresFree  Then
			
			DiskArray(I).ThreshCountAbove = DiskArray(I).ThreshCountAbove + 1

			'If debugging is enabled information is written to a text file
			If Ucase(debug) = "Y" Then 
				Print #2,""
				Print #2,""
				Print #2," Current Utilisation or free space over threshold ThreshCountAbove : " & DiskArray(I).ThreshCountAbove
			End If

			' this checks whether this event has occured the required number of times for an event to be fired
			If DiskArray(I).ThreshCountAbove >= CONSEC_TIME_ABOVE Then 
				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2,""
					Print #2," This event has now occured consequtively the CONSEC_TIME_ABOVE number of times"
					Print #2," We have now seen the event " & CONSEC_TIME_ABOVE & " Times"
					Print #2,""	
					Print #2,""	
				End If

				'This checks to see if the Utilisation is the reason 
				If DiskArray(I).CurrentUtil > DiskArray(I).ThresUtil Then
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2,""
						Print #2," Current Utilisation is above Threshold on Drive : " & DiskArray(I).DiskName
						Print #2,""	
					End If

					'if it is than a message is built up stating this
					LongMsg = "Disk "  &  DiskArray(I).DiskName & " Used % is " & Format$(DiskArray(I).CurrentUtil, "0.00") & "; >TH = " & CStr(DiskArray(I).ThresUtil) & chr$(10)
					ShortMsg = Format$(DiskArray(I).CurrentUtil, "0.00") & "%"

				End If

				'This checks to see if the free space is the reason 
				If DiskArray(I).CurrentFree < DiskArray(I).ThresFree Then
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2,""
						Print #2," Current Free Space is Below Threshold on Drive : " & DiskArray(I).DiskName
						Print #2,""	
					End If


					LongMsg = LongMsg &	"Free space MB is " & Format$(DiskArray(I).CurrentFree, "0.00") & "; <TH = " & CStr(DiskArray(I).ThresFree)
					If ShortMsg <> "" Then
						ShortMsg = ShortMsg & "-" & Format$(DiskArray(I).CurrentFree, "0.00") & "MB"
					Else
						ShortMsg = Format$(DiskArray(I).CurrentFree, "0.00") & "MB"
					End If
				End If

				' for Command post messages the message should not conatin spaces, so these are replaced with hyphens
				If DO_NUMBERS = "y" Then
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2,""
						Print #2," Do Numbers is True"
						Print #2,""	
					End If
					ShortMsg = "LogicalDisk" & " " & AlterString("Disk " & DiskArray(I).DiskName & " Full", " " , "-") & " " & ShortMsg
				Else
					'If debugging is enabled information is written to a text file
					If Ucase(debug) = "Y" Then 
						Print #2,""
						Print #2," Do Numbers is False"
						Print #2,""	
					End If
					' for Command post messages the message should not conatin spaces, so these are replaced with hyphens
					ShortMsg = "LogicalDisk" & " " & AlterString("Disk " & DiskArray(I).DiskName & " Full", " " , "-") & " NULL"
				End If				
				' Send message using whatever method the Script has bee setup to use
				MSActions SEVERITY, ShortMsg, AKPID, ResName, LongMsg
				'once a message has been sent the counters must be reset so that another occurence can be monitored.
				'DiskArray(I).ThreshCountBelow=0
				DiskArray(I).ThreshCountAbove=0
				'This is used for firing another event if the thresholds are not breached.
				DiskArray(I).EventFired= "True"

				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2,""
					Print #2,""
					Print #2," Disk Name 						 : " & DiskArray(I).DiskName
					Print #2,""	
					Print #2," Short Message 					 : " & ShortMsg
					Print #2,""	
					Print #2," Long Message 					 : " & LongMsg
					Print #2,""				
					Print #2,""		
				End If		
			Else

			End If
		'This section is run if the counters are not over the thresholds, this also must be checked as another message
		'may need to be sent to tell command post that the problem has been resolved.
		ElseIf DO_EVENT = "y" And DiskArray(I).CurrentUtil < DiskArray(I).ThresUtil Or DiskArray(I).CurrentFree > DiskArray(I).ThresFree Then
			'If debugging is enabled information is written to a text file
			If Ucase(debug) = "Y" Then 
				Print #2,""
				Print #2,""
				Print #2," Current Utilisation or free space below threshold ThreshCountBelow : " & DiskArray(I).ThreshCountBelow
				Print #2,""
			End If
			'If this section is run then the thresholds have not been breached this time so the couter for how many time they 
			'have been breached is set to 0
			'DiskArray(I).ThreshCountAbove = 0

			'Only if an event has been fored for this object will this section run, eventfired= true, this stops the event being fired 
			'when the script starts
 			If DiskArray(I).EventFired= "True" And DiskArray(I).ThreshCountBelow >= CONSEC_TIME_BELOW Then
				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2,""
					Print #2," This Section Only Occurs if an Event for Count above CONSEC_TIME_ABOVE has fired and the number"
					Print #2," Of Clear Events is = CONSEC_TIME_BELOW value "	
					Print #2,""
				End If
				'Build normal message
				LongMsg = "Disk "  &  DiskArray(I).DiskName & " Used % is " & Format$(DiskArray(I).CurrentUtil, "0.00") & "; <TH = " & CStr(DiskArray(I).ThresUtil) & chr$(10)
				LongMsg = LongMsg &	"Free space MB is " & Format$(DiskArray(I).CurrentFree, "0.00") & "; >TH = " & CStr(DiskArray(I).ThresFree)
				ShortMsg = Format$(DiskArray(I).CurrentUtil, "0.00") & "%-" & Format$(DiskArray(I).CurrentFree, "0.00") & "MB"

				' for Command post messages the message should not conatin spaces, so these are replaced with hyphens
				If DO_NUMBERS = "y" Then
					ShortMsg = "LogicalDisk" & " " & AlterString("Disk "  &  DiskArray(I).DiskName & " Utilization Normal", " ", "-") & " " & ShortMsg
					If Ucase(debug) = "Y" Then Print #2,""
					If Ucase(debug) = "Y" Then Print #2, shortmsg
					If Ucase(debug) = "Y" Then Print #2,""	
				Else
					ShortMsg = "LogicalDisk" & " " & AlterString("Disk "  &  DiskArray(I).DiskName & " Utilization Normal", " ", "-")
					If Ucase(debug) = "Y" Then Print #2,""
					If Ucase(debug) = "Y" Then Print #2, shortmsg
					If Ucase(debug) = "Y" Then Print #2,""	
				End If
				'Send message
				MSActions 40, ShortMsg, AKPID, ResName, LongMsg
				'once event has been fired it does not need to be sent again 				
				DiskArray(I).ThreshCountBelow = 0
				DiskArray(I).EventFired= "False"
				'If debugging is enabled information is written to a text file
				If Ucase(debug) = "Y" Then 
					Print #2,""
					Print #2," Disk Name 						 : " & DiskArray(I).DiskName
					Print #2,""	
					Print #2," Short Message 					 : " & ShortMsg
					Print #2,""	
					Print #2," Long Message 					 : " & LongMsg
					Print #2,""				
					Print #2,""				
				End If
			Else
				'otherwise this is another below threshold message so increment the couter until it gets to the point when the event is fired.
				DiskArray(I).ThreshCountBelow = DiskArray(I).ThreshCountBelow +1
			End If
		End If
	Next I
 Close #2
End Sub


'this checks to see if any of the object names match the value that is passed in
Function Exists(ByRef sDisk As String) As Variant
	
	Dim nDiskCount As Integer
	Dim I As Integer
	nDiskCount = UBound(DiskArray)

	Exists = False
	For I = 0 To nDiskCount
		If sDisk = DiskArray(I).DiskName Then
			Exists = True
			Exit For
		End If
	Next I

End Function


Sub Main()

	'This assigns the object that need to be read
	Set NT = CreateObject("NetiQAgent.NT")
	Set OBJ = NT.System
	'Setup the variable storing the number of times the script has been run.
	NoofInteration = Iterationcount()

	'If debugging is enabled information is written to a text file	
	If Ucase(debug) = "Y" Then
		Open "c:\logdisk.txt" For Append Access Write As #2
		Print #2, ""
		Print #2, "****************************************************************************"
		Print #2, ""
		Close #2
	End If

	' Create a array of all disks and their thresholds limits to accomodate for both MB free and % used

	CreateDiskArray

	' Swapp DiskArray with the NewDiska Array

	SwappArrays

	' Display events 

	DisplayEvent

	'If debugging is enabled information is written to a text file
	If Ucase(debug) = "Y" Then
		Open "c:\logdisk.txt" For Append Access Write As #2
		Print #2, ""
		Print #2, "****************************************************************************"
		Print #2, ""
		Close #2
	End If

End Sub


'### End KPS Section


