'### This is an .ebs file generated by KSCheckout.
'### It can be checked in to the repository by invoking kscheckin.
'###
'### AMAdmin_ManagedObjectInstall

'### Begin KP-Version Section
Const AppManID = "3.1.10.0.6"
Const KSVerID = "1.1"
'Comment = 
'Log:
'%KSVerID=1.0, %Date=05/16/2000, %Time=16:44:09, %User=EUROPE1\PaulCurtis (sa), %TZ=GMT S
'	(none)


'### End KP-Version Section

'### Begin KP-Status Section
'NeedKPW = 0
'AdminOnly = 1
'DisplayToolBar = 1
'IAmDiscovery = 0
'RunRightAway = 0
'IAmAction = 0
'IAmInstall = 1
'ObjFullPath = 0
'Description = Installs an AppManager managed object on a remote computer.

'### End KP-Status Section

'### Begin KPC Section
'Parameters = 0 1 0 1 0 1 1 1 0 99991231 0 235959

'### End KPC Section

'### Begin Type Section
Const NT_MachineFolder = ""

'### End Type Section

'### Begin KPP Section
'[V<Installs an AppManager managed object on a remote computer. The management server and remote computer must be in the same domain or trusted domains. For path/filename, use UNC; for example, \\shasta\share\setup.exe. Click Help for more information.>V]
Const DO_EVENT = "y" 	'[M<Raise an event when installation completes successfully?>M] [T<String,1,,"yn">T]
Const Severity = 15		'[M<Event severity level when installation is successful>M] [T<Integer,,,1, 40, SevLevel>T]
Const User = "netiq"			'[M<User name for remote install>M] [T<Req_String,128,'^',>T]
Const Password = "netiq"	    '[M<Password for remote install user>M][T<string,32,'^',"">T][I<I_EDIT(2)>I]
Const Domain = ""		'[M<Domain of remote install user>M] [T<Req_String,128,'^',>T]
Const TempDir = "c:\temp\MOInstall"		'[M<Temporary directory on the remote computer>M] [T<Req_String,128,'^',>T] 
Const SrcFile = ""		'[M<Path and filename of the setup program>M] [T<Req_String,128,'^',>T] 


'[A<If "Raise an event when complete" is set to y and an event occurs, the selected action is taken.>A]
Const AKPID = "AKP_NULL"	' [M<Action taken>M]

'### End KPP Section

'### Begin KPS Section
Type PROCESS_INFO
	hProcess As Long
	hThread As Long
	dwProcessId As Long
	dwThreadId As Long
End Type

Type STARTUPINFO
	cb As Long
	lpReserved As String
	lpDesktop As String
	lpTitle As String
	dwX As Long
	dwY As Long
	dwXSize As Long
	dwYSize As Long
	dwXCountChars As Long
	dwYCountChars As Long
	dwFillAttribute As Long
	dwFlags As Long
	wShowWindow As Integer
	cbReserved2 As Integer
	lpReserved2 As Long
	hStdInput As Long
	hStdOutput As Long
	hStdError As Long
End Type

Declare Function CreateProcess Lib "kernel32" Alias _
	"CreateProcessA" (ByVal lpApplicationName As String, _
		ByVal lpCommandLine As String, _
		ByVal lpProcessAttributes As Any, _
      	ByVal lpThreadAttributes As Any, _
		ByVal bInheritHandles As Long, _
      	ByVal dwCreationFlags As Long, _
		ByVal lpEnvironment As Any, _
		ByVal lpCurrentDirectory As String, _
		lpStartupInfo As STARTUPINFO, _
      	lpProcessInformation As PROCESS_INFO) As Boolean

Declare Sub CloseHandle Lib "kernel32.dll" Alias _
	"CloseHandle" (ByVal hObject As Long) 

Declare Function WaitForSingleObject Lib "kernel32.dll" Alias _
	"WaitForSingleObject" (ByVal hHandle As Long, _
		ByVal dwMilliSec As Long) As Long

Declare Function GetExitCodeProcess Lib "kernel32.dll" Alias _
	"GetExitCodeProcess" (ByVal hProcess As Long, _
		ExitCode As Long) As Boolean

Declare Function GetCurrentThreadId Lib "kernel32.dll" Alias _
	"GetCurrentThreadId" () As Long




Const NORMAL_PRIORITY_CLASS = &H20&
Const STARTF_USESHOWWINDOW  = &H1&
Const STARTF_USESTDHANDLES  = &H100&
Const SW_HIDE       = &H0&
Const INFINITE      = &HFFFFFFFF&
Const STILL_ACTIVE  = &H103&
Const WAIT_FAILED   = &HFFFFFFFF&
Const WAIT_OBJECT_0 = &H0&


'
'  win32 registry functions
'
Global Const REG_SZ As Long = 1
Global Const REG_DWORD As Long = 4 
Global Const HKEY_CLASSES_ROOT = &H80000000 
Global Const HKEY_CURRENT_USER = &H80000001 
Global Const HKEY_LOCAL_MACHINE = &H80000002 
Global Const HKEY_USERS = &H80000003 
Global Const ERROR_NONE = 0 
Global Const ERROR_BADDB = 1 
Global Const ERROR_BADKEY = 2 
Global Const ERROR_CANTOPEN = 3 
Global Const ERROR_CANTREAD = 4 
Global Const ERROR_CANTWRITE = 5 
Global Const ERROR_OUTOFMEMORY = 6 
Global Const ERROR_INVALID_PARAMETER = 7 
Global Const ERROR_ACCESS_DENIED = 8 
Global Const ERROR_INVALID_PARAMETERS = 87 
Global Const ERROR_NO_MORE_ITEMS = 259 
Global Const KEY_ALL_ACCESS = &H3F 
Global Const KEY_READ       = &H19

Declare Function RegCloseKey Lib "advapi32.dll" _ 
		(ByVal hKey As Long) As Long 
Declare Function RegOpenKeyEx Lib "advapi32.dll" Alias _ 
		"RegOpenKeyExA" (ByVal hKey As Long, ByVal lpSubKey As String, _ 
		ByVal ulOptions As Long, ByVal samDesired As Long, ByRef phkResult As Long) As Long 
Declare Function RegQueryValueExString Lib "advapi32.dll" Alias _ 
		"RegQueryValueExA" (ByVal hKey As Long, ByVal lpValueName As _ 
		String, ByVal lpReserved As Long, lpType As Long, ByVal lpData _
		As String, lpcbData As Long) As Long 

Declare Function RegConnectRegistry Lib "advapi32.dll" Alias _
                "RegConnectRegistryA" (ByVal lpMachineName As String, ByVal hkey As Long, _
                ByRef phkResult As Long) As Long 


'
	Dim bError As Boolean
	Dim bWarning As Boolean

'
'
Const InstallMgrCmd = "nqsms_m.exe"
Const Quo = """"				
Const NL = chr$(10)	 			' newline
Const CR = chr$(13)	 			' newline
Dim OSVersionHost As String			'crs 8219
Dim OSVersionTarget As String			'crs 8219

'
'  return TRUE if error string found
'
Function GetResultData (ByVal dwProcessId As Long, ByRef sResultData As String)	_
		As Boolean
  	Dim sEnvironTemp As String
	Dim sDataFile As String
	Dim sDataLine As String

	sResultData = ""
	GetResultData = FALSE	
	If (dwProcessId = 0)  Then
		GoTo OUT
	End If
	'
	'  +++ cache
	'	 
	'sEnvironTemp = Environ("TEMP")
	sEnvironTemp = GetInstallPath()	
	sDataFile = sEnvironTemp + "\nqsms" + Cstr(dwProcessId) + ".txt" 
	If (Not FileExists(sDataFile))  Then
		GoTo OUT
	End If
	Open sDataFile For Input As #9
	While Not EOF(9)
		Line Input #9, sDataLine
		If (InStr(1, sDataLine, "WARNING", 1)) Then
			 GetResultData =  TRUE
			 bWarning = TRUE
			 sResultData = sResultData & NL & sDataLine
		End If
		If (InStr(1, sDataLine, "ERROR", 1)) Then
			 GetResultData =  TRUE
			 bError = TRUE
			sResultData = sResultData & NL & sDataLine
		End If
	Wend
	Close #9
	kill sDataFile
OUT:
	Exit Function
 End Function


'
'	0 success
'	> 0 fail
'
Function RunCmd (ByVal cmdLine As String, ByRef dwProcessId As Long) As Long
	Dim pInfo As PROCESS_INFO
	Dim sInfo As STARTUPINFO
	Dim sNull As String
	Dim success As Boolean
 	Dim ret As Long
	Dim exitCode As Long
	Dim errormsg As String
	Dim eventmsg As String
	Dim resname As String
	Dim fileSize As Integer
	Dim errorOut As Boolean
	
	resname = "NT_MachineFolder = " & NT_MachineFolder
	success = True
   	sInfo.dwFlags = STARTF_USESHOWWINDOW
	sInfo.wShowWindow = SW_HIDE
	sInfo.cb = Len(sInfo)
	success = CreateProcess (sNull, cmdLine, 0&, 0&, 0&, NORMAL_PRIORITY_CLASS, _
		0&, sNull, sInfo, pInfo)
	If (success = FALSE) Then
		errormsg = "Cannot create the installation service (nqexecd) on the remote computer."
		dwProcessId = 0
		MSActions 5, eventmsg, AKPID, resname, errormsg
		RunCmd = 1024
		Exit Function
	End If
	dwProcessId = pInfo.dwProcessID

	'ret = WaitForSingleObject (pInfo.hProcess, INFINITE)
	'If (ret <> WAIT_OBJECT_0) Then
	ret = MCWaitForObject(TRUE, pInfo.hProcess)
	If (ret = 0) Then
		' Failed.
		errormsg = "Failed to wait process with " & ret
		success = FALSE
		GoTo OUT
	End If
	success = GetExitCodeProcess(pInfo.hProcess, exitCode)
	
	If (FALSE = success) Then
		errormsg = "Did not receive an exit code for the installation service (nqexecd)."
		GoTo OUT
	End If
   	RunCmd = exitCode

OUT:
	If (success = FALSE) Then
		MSActions 5, eventmsg, AKPID, resname, errormsg
		RunCmd = 1024
	End If
	CloseHandle (pInfo.hProcess)
	CloseHandle (pInfo.hThread)
End Function
'
'
Function GetInstallPath() As String
	Dim lRetVal&, hKey&, ValLen&, DataName$, DataLen&, rc&
	
	GetInstallPath = ""
	lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\NetIQ\AppManager", 0, _
		KEY_ALL_ACCESS, hKey)
	If (lRetVal <> ERROR_NONE) Then
		GoTo OUT
	End If
	DataLen = 256
	DataName = String$(DataLen, 0)	
	lRetVal = RegQueryValueExString(hKey, "InstallPath", 0&, REG_SZ, DataName, DataLen)
	If (lRetVal <> ERROR_NONE) Then
		GoTo OUT
	End If
	DataName = Left$(DataName, DataLen-1)
	DataName = Trim$(DataName)
	GetInstallPath = DataName
OUT:
	lRetVal = RegCloseKey (hKey)
End Function


Function GetPlatformInfo() As String
	Dim lRetVal&, hKey&, hKeyServer&, ValLen&, DataName$, DataLen&, rc&
	
	GetPlatformInfo = ""
    lRetVal  = RegConnectRegistry("\\"&NT_MachineFolder, HKEY_LOCAL_MACHINE, hKeyServer)
	If (lRetVal <> ERROR_NONE) Then 
		errormsg = "Cannot connect to the remote computer " & NT_MachineFolder
	    GoTo Out 
	End If
	lRetVal = RegOpenKeyEx(hKeyServer, "SYSTEM\CurrentControlSet\Control\Session Manager\Environment", 0, _
		KEY_READ, hKey)

	DataLen = 256
	DataName = String$(DataLen, 0)	
	lRetVal = RegQueryValueExString(hKey, "Processor_Architecture", 0&, REG_SZ, DataName, DataLen)
	If (lRetVal <> ERROR_NONE) Then
		GoTo OUT
	End If
	DataName = Left$(DataName, DataLen-1)
	DataName = Trim$(DataName)
	GetPlatformInfo = DataName
OUT:
	lRetVal = RegCloseKey (hKey)
	lRetVal = RegCloseKey (hKeyServer)
End Function

Function GetOSVersion (ByRef osHost As String, ByRef osTarget As String) As Boolean	'crs 8219
	Dim lRetVal&, hKey&, hKeyServer&, DataName$, DataLen&
	'get host os version
   	lRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\Microsoft\Windows NT\CurrentVersion", 0, _
		KEY_READ, hKey)
	
	DataLen = 256
	DataName = String$(DataLen, 0)	
	lRetVal = RegQueryValueExString(hKey, "CurrentVersion", 0&, REG_SZ, DataName, DataLen)
	If (lRetVal <> ERROR_NONE) Then
		GoTo OUT
	End If
	DataName = Left$(DataName, DataLen-1)
	DataName = Trim$(DataName)
	osHost = DataName
	lRetVal = RegCloseKey (hKey)

	'get target os version
	DataName=""
    lRetVal  = RegConnectRegistry("\\" & NT_MachineFolder, HKEY_LOCAL_MACHINE, hKeyServer)
	If (lRetVal <> ERROR_NONE) Then 
	    GoTo Out 
	End If
	lRetVal = RegOpenKeyEx(hKeyServer, "Software\Microsoft\Windows NT\CurrentVersion", 0, _
		KEY_READ, hKey)
	 
	DataLen = 256
	DataName = String$(DataLen, 0)	
	lRetVal = RegQueryValueExString(hKey, "CurrentVersion", 0&, REG_SZ, DataName, DataLen)
	If (lRetVal <> ERROR_NONE) Then
		GoTo OUT
	End If
	DataName = Left$(DataName, DataLen-1)
	DataName = Trim$(DataName)
	osTarget = DataName
	
OUT:
	lRetVal = RegCloseKey (hKey)
	lRetVal = RegCloseKey (hKeyServer)

End Function

Function GetXcopy (ByVal osVersion As String) As String	'crs 8219
	Dim XcopyCmd As String

	If osVersion = "5.0" Then
		XcopyCmd = "cmd /c xcopy /q /y " 
	ElseIf osVersion = "4.0" Then
		XcopyCmd = "cmd /c xcopy /q "
	Else
		XcopyCmd = "cmd /c xcopy /q " 
	End If

	GetXcopy = XcopyCmd		 
End Function

'
Sub Main()
	Dim bRet As Long
	Dim cmdLine As String
	Dim sTempDir As String
  	Dim ret As String
	Dim errorOut As Boolean
	Dim sUNC As String
	Dim errormsg As String
	Dim eventmsg As String
	Dim resname As String
	Dim dwProcessId As Long
   	Dim sResultData As String
	Dim bRc As Boolean
	Dim sEventMessage As String	
	Dim sLogFileName As String
	Dim nSleep As Long
    Dim sCPUType As String
	Dim tUNC As String
	Dim sTmpStr As String
	Dim cmdXcopyHost As String	'crs 8219
	Dim cmdXcopyTarget As String	'crs 8219
	Dim getOSError As Boolean		'crs 8219
	
	sCPUType = GetPlatformInfo()
	getOSError = GetOSVersion(OSVersionHost, OSVersionTarget)	'crs 8219

  	eventmsg = "AppManager managed object installation failed."
	'
	'  x msec delay between setup 
	'
	nSleep = 30000
	bError = FALSE
	bWarning = FALSE
   	resname = "NT_MachineFolder = " & NT_MachineFolder
	'
	'  Sanity check
	'
	If (TempDir = "") Then
		' Terminate the job.
		errormsg = "Specify a temporary directory on the remote computer."
		GoTo OUT
	End If
	If (SrcFile = "") Then
		' Terminate the job.
		errormsg = "Specify the path and filename of the setup program."
		GoTo OUT
	End If

	'		
	'  append \ to the end of path to make xcopy and del happy
	'  replace : with $ for driver letter.
	'
	If (Mid(TempDir, Len(TempDir), Len(TempDir)) <> "\")  Then
		sTempDir = TempDir & "\"
	Else
		sTempDir = TempDir
	End If
	iWhere = InStr(sTempDir, ":")
	If (iWhere <> 0)  Then
		tUNC = "\\" & NT_MachineFolder & "\" & Mid(sTempDir, 1, iWhere - 1) & "$" &_
			Mid(sTempDir, iWhere + 1, Len(sTempDir))
	Else
		tUNC = "\\" & NT_MachineFolder & "\" & sTempDir
	End If
	sTempDir = sTempDir & "MOInstall\"
	sUNC = tUNC & "MOInstall\"
	'
	'
	'
	sTmpStr = SrcFile
	iWhere = InStr(1, sTmpStr, "\")
	While (iWhere <> 0)  
		sTmpStr = Mid(sTmpStr, iWhere + 1) 
		iWhere = InStr(1, sTmpStr, "\")	
	Wend 
	'
	'
	'

	lRet = RunCmd("cmd /c md " & sUNC, dwProcessId)
	 cmdXcopyHost = GetXcopy(OSVersionHost)
	
	'If (  UCase$(sCPUType) = "X86" ) Then
	'	lRet = RunCmd("cmd /c xcopy /q " & GetInstallPath() & "\bin\nqsms_a.exe " & sUNC, dwProcessId) 	
	'Else
	'	lRet = RunCmd("cmd /c xcopy /q " & GetInstallPath() & "\bin\nqsms_aa.exe " & sUNC, dwProcessId) 	
	'	lRet = RunCmd("cmd /c xcopy /q " & GetInstallPath() & "\bin\nquninsta.exe " & sUNC, dwProcessId)
	'	lRet = RunCmd("cmd /c copy " & sUNC & "nqsms_aa.exe " & sUNC & "nqsms_a.exe", dwProcessId)
	'	lRet = RunCmd("cmd /c copy " & sUNC & "nquninsta.exe " & sUNC & "nquninst.exe", dwProcessId)
	'End If
	'lRet = RunCmd("cmd /c xcopy /q " & SrcFile & " " & sUNC, dwProcessId)
	
	If (  UCase$(sCPUType) = "X86" ) Then
		lRet = RunCmd(cmdXcopyHost & GetInstallPath() & "\bin\nqsms_a.exe " & sUNC, dwProcessId) 	
	Else
		lRet = RunCmd(cmdXcopyHost & GetInstallPath() & "\bin\nqsms_aa.exe " & sUNC, dwProcessId) 	
		lRet = RunCmd(cmdXcopyHost & GetInstallPath() & "\bin\nquninsta.exe " & sUNC, dwProcessId)
		lRet = RunCmd("cmd /c copy " & sUNC & "nqsms_aa.exe " & sUNC & "nqsms_a.exe", dwProcessId)
		lRet = RunCmd("cmd /c copy " & sUNC & "nquninsta.exe " & sUNC & "nquninst.exe", dwProcessId)
	End If
	lRet = RunCmd(cmdXcopyHost & SrcFile & " " & sUNC, dwProcessId)

    If (lRet <> 0) Then
 		errormsg =  "Error copying setup program to remote computer " & sUNC & "." & CR & NL & _
					"Verify that the NetIQmc and NetIQccm services on the management server are running as an NT account with permission to access the remote computer " & sUNC & CR & NL & _
					"Also verify that the installation service (nqexecd) is not already running on the remote computer."
		' Terminate the job.
 		GoTo OUT
    End If

	'
	'
	' 
	cmdLine = InstallMgrCmd & " -agent " & NT_MachineFolder & " "
	lRet = RunCmd(cmdLine & "-create -path " & sTempDir & "nqsms_a.exe", dwProcessId)
 	If (lRet <> 0)  Then 
		errormsg = 	  "Cannot create the installation service (nqexecd) on the remote computer."
 		'MSActions 5, eventmsg, AKPID, resname, "Error: Failed to create nqexecd service"
		bError = TRUE
  		GoTo CLEAN_SERVICE
 	End If
	lRet = RunCmd(cmdLine & "-start", dwProcessId)
	If (lRet <> 0)  Then
		errormsg =   "Cannot start the installation service (nqexecd) on the remote computer."
 		'MSActions 5, eventmsg, AKPID, resname, "Error: Failed to start nqexecd service"
		bError = TRUE
		GoTo CLEAN_SERVICE
	End If
	'
	'  the user setup will run as
	'
	lRet = RunCmd(cmdLine & "-request @TEMP -data " & QUO & sTempDir & QUO, dwProcessId)
	lRet = RunCmd(cmdLine & "-request @domain -data " & QUO & Domain & QUO, dwProcessId)
	lRet = RunCmd(cmdLine & "-request @user -data " & QUO & User & QUO, dwProcessId)
	lRet = RunCmd(cmdLine & "-request @passwordee -data " & QUO & Password & QUO, dwProcessId)

	'
	'  if logon failed, it will happen here...
	'
	If (lRet = 1)  Then
		bRc = GetResultData(dwProcessId, sResultData)
		If (bRc = TRUE)  Then
			errormsg = errormsg & NL & sResultData	
		End If
		GoTo CLEAN_SERVICE
    End If
	sLogFileName = "\moinst.err"
	lRet = RunCmd(cmdLine & "-request " & Quo & sTempDir & sTmpStr & " -s" & Quo & " -data %windir%" & sLogFileName, dwProcessId)
	bRc = GetResultData(dwProcessId, sResultData)

	If (Len(sResultData) > 0)  Then
		errormsg = errormsg & NL & sResultData	
	End If
	
	'
	'	clean up
	'
CLEAN_SERVICE:
	lRet = RunCmd(cmdLine & "-stop", dwProcessId)
	lRet = RunCmd(cmdLine & "-delete", dwProcessId)
CLEAN_FILES:
	If Len(sUNC) = 0 Then GoTo OUT1
	lRet = RunCmd("cmd /c del /q /s " & sUNC & "\", dwProcessId)	
	If (lRet <> 0)  Then
		bWarning = TRUE
		errormsg = errormsg & NL & _ 
			"Warning: Cannot delete the temporary files on the remote computer."
		GoTo OUT1
	End If
	lRet = RunCmd("cmd /c rmdir /Q /S " & sUNC & "\", dwProcessId)
	If (lRet <> 0)  Then
		bWarning = TRUE
		errormsg = errormsg & NL & _
			"Warning: Cannot delete temporary directory on the remote computer. " & sUNC
		GoTo OUT1
	End If
	lRet = RunCmd("cmd /c rmdir /q " & tUNC & "\", dwProcessId)
OUT1:
	'
	'
	'
	sEventMessage = "AppManager managed object was successfully installed."
	If (bError)  Then
		sEventMessage = "AppManager managed object installation failed."	
	End If 
	If (bWarning) Then
		sEventMessage = "AppManager managed object installation was partially completed."	
	End If	
	'
	'  report error or warning.  report success only if user wants it.
	'
	If (bError) Then
		MSActions 1, sEventMessage, AKPID, NT_MachineFolder, errormsg	
    ElseIf (bWarning) Then
		MSActions Severity, sEventMessage, AKPID, NT_MachineFolder, errormsg
	Else
        If (DO_EVENT = "y")  Then
 			MSActions Severity, sEventMessage, AKPID, NT_MachineFolder, errormsg
		End If		
	End If
	Exit Sub
OUT:
	'  !!! avoid using mcabort
	MCAbort resname, errormsg
	'
End Sub


'### End KPS Section

